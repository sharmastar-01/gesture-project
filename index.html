<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini AI - Gesture Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #info { 
            position: absolute; top: 20px; left: 20px; color: white; 
            pointer-events: none; z-index: 10; text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        canvas { display: block; }
        .status { color: #00ffff; font-weight: bold; }
    </style>
</head>
<body>
    <div id="info">
        <h2>Hand Morph Particles</h2>
        <p>1. Allow Camera Access</p>
        <p>2. Show hand to control shape:</p>
        <ul>
            <li>0-1 Fingers: <span class="status">Sphere</span></li>
            <li>2-3 Fingers: <span class="status">Heart</span></li>
            <li>4-5 Fingers: <span class="status">Flower</span></li>
        </ul>
        <p>3. Pinch to <span class="status">Scale</span> | Move to <span class="status">Change Color</span></p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. CONFIG & STATE ---
        const PARTICLE_COUNT = 15000;
        let handData = { x: 0, y: 0, pinch: 0.1, fingersUp: 0, active: false };

        // --- 2. THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 4;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 3. SHADERS ---
        const vertexShader = `
            uniform float uTime;
            uniform float uMorph;
            uniform float uExpansion;
            uniform vec3 uColor;
            attribute vec3 target1; 
            attribute vec3 target2; 
            varying vec3 vColor;

            void main() {
                vec3 pos = position;
                if(uMorph < 1.0) {
                    pos = mix(position, target1, uMorph);
                } else {
                    pos = mix(target1, target2, uMorph - 1.0);
                }

                pos *= (uExpansion * 1.5);
                
                pos.x += sin(uTime * 0.5 + pos.z) * 0.1;
                pos.y += cos(uTime * 0.5 + pos.x) * 0.1;

                vColor = uColor;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = (6.0 * uExpansion) * (1.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            void main() {
                float d = distance(gl_PointCoord, vec2(0.5));
                if (d > 0.5) discard;
                gl_FragColor = vec4(vColor, 1.0 - (d * 2.0));
            }
        `;

        // --- 4. GEOMETRY ---
        const geo = new THREE.BufferGeometry();
        const basePos = [];
        const heartPos = [];
        const flowerPos = [];

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // Sphere
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.acos(Math.random() * 2 - 1);
            basePos.push(Math.sin(theta) * Math.cos(phi), Math.sin(theta) * Math.sin(phi), Math.cos(theta));

            // Heart
            const t = Math.random() * Math.PI * 2;
            heartPos.push(
                0.15 * (16 * Math.pow(Math.sin(t), 3)),
                0.15 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)),
                (Math.random() - 0.5) * 0.2
            );

            // Flower
            const angle = Math.random() * Math.PI * 2;
            const r = Math.sin(5 * angle) + 1.5; 
            flowerPos.push(r * Math.cos(angle) * 0.8, r * Math.sin(angle) * 0.8, (Math.random() - 0.5) * 0.2);
        }

        geo.setAttribute('position', new THREE.Float32BufferAttribute(basePos, 3));
        geo.setAttribute('target1', new THREE.Float32BufferAttribute(heartPos, 3));
        geo.setAttribute('target2', new THREE.Float32BufferAttribute(flowerPos, 3));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uMorph: { value: 0 },
                uExpansion: { value: 1 },
                uColor: { value: new THREE.Color(0x00ffff) }
            },
            vertexShader,
            fragmentShader,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const points = new THREE.Points(geo, material);
        scene.add(points);

        // --- 5. MEDIAPIPE LOGIC ---
        // Using window.Hands to ensure global access
        const hands = new window.Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks[0]) {
                handData.active = true;
                const marks = results.multiHandLandmarks[0];
                
                // Position Tracking
                handData.x = (marks[9].x - 0.5) * 6;
                handData.y = (marks[9].y - 0.5) * -6;

                // Pinch Calculation
                const dx = marks[4].x - marks[8].x;
                const dy = marks[4].y - marks[8].y;
                handData.pinch = Math.sqrt(dx*dx + dy*dy);

                // Finger Counting
                let count = 0;
                [8, 12, 16, 20].forEach(tip => {
                    if (marks[tip].y < marks[tip-2].y) count++;
                });
                handData.fingersUp = count;
            } else {
                handData.active = false;
            }
        });

        const videoElement = document.createElement('video');
        const cameraUtils = new window.Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();

        // --- 6. ANIMATION ---
        function animate(time) {
            requestAnimationFrame(animate);
            material.uniforms.uTime.value = time * 0.001;

            if (handData.active) {
                // Follow hand
                const targetPos = new THREE.Vector3(handData.x, handData.y, 0);
                points.position.lerp(targetPos, 0.1);

                // Morphing
                let targetMorph = 0;
                if(handData.fingersUp >= 2 && handData.fingersUp < 4) targetMorph = 1.0;
                if(handData.fingersUp >= 4) targetMorph = 2.0;
                material.uniforms.uMorph.value = THREE.MathUtils.lerp(material.uniforms.uMorph.value, targetMorph, 0.05);

                // Expansion (Pinch)
                const targetExp = 0.5 + (handData.pinch * 5.0);
                material.uniforms.uExpansion.value = THREE.MathUtils.lerp(material.uniforms.uExpansion.value, targetExp, 0.1);

                // Color
                const hue = (handData.x + 3) / 6;
                material.uniforms.uColor.value.setHSL(hue % 1.0, 0.8, 0.6);
            } else {
                // Idle floating state
                points.position.lerp(new THREE.Vector3(0,0,0), 0.05);
                material.uniforms.uMorph.value = THREE.MathUtils.lerp(material.uniforms.uMorph.value, 0, 0.02);
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate(0);
    </script>
</body>
</html>
